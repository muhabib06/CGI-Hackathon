# generate_tests.py
# Generates Pytest test cases for the mock server based on OpenAPI and test data.

import json
import sys
import os
from termcolor import colored
import io
from collections import defaultdict

# Ensuring console output is correctly encoded (though file content is now ASCII)
# NOTE: The file content is now guaranteed to be pure ASCII for maximum compatibility.
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

# --- Configuration ---
OPENAPI_FILE = "openapi_definition.json"
TESTDATA_FILE = "testdata.json"

def create_api_tests(spec_filename: str = OPENAPI_FILE, data_filename: str = TESTDATA_FILE):
    # Generates a Pytest file (test_mock_api.py) for the CRUD operations.
    
    print("\n--- 5. PYTEST GENERATOR STARTED (Addressing Step 5) ---")
    
    try:
        # 1. Read input data
        with open(spec_filename, 'r', encoding='utf-8') as f:
            spec = json.load(f)
        with open(data_filename, 'r', encoding='utf-8') as f:
            test_data_raw = json.load(f)
    except FileNotFoundError as e:
        print(colored(f"❌ ERROR: File not found: {e}. Please run main.py first.", 'red'))
        sys.exit(1)
    except json.JSONDecodeError:
        print(colored(f"❌ ERROR: Could not decode JSON.", 'red'))
        sys.exit(1)

    # 2. Determine resource path
    try:
        # Find the first path that does not contain {id}
        resource_path_plural = next((p for p in spec['paths'] if '{' not in p), None)
        if not resource_path_plural:
            # Fallback
             resource_path_plural = next(iter(spec['paths'])).split('/{')[0]
             
        # API Base URL for tests
        api_base = "http://127.0.0.1:8000" + resource_path_plural 
        
    except Exception as e:
        print(colored(f"❌ ERROR parsing OpenAPI Spec: {e}", 'red'))
        sys.exit(1)
        
    # 3. Prepare payloads as formatted strings
    try:
        # Take the first positive test case
        create_payload_data = next((d for d in test_data_raw if 'scenario' in d and 'Positive' in d['scenario']), None)
        if create_payload_data is None:
            # Fallback
            create_payload_data = test_data_raw[0].copy()
            
        update_payload_data = test_data_raw[1].copy() if len(test_data_raw) > 1 else create_payload_data.copy()
        
        
        create_payload_data.pop('id', None) 
        update_payload_data.pop('id', None) 
        
        # Convert payloads to formatted strings for the f-string
        # NOTE: Using 4 spaces for indentation explicitly.
        TEST_CREATE_PAYLOAD_STR = json.dumps(create_payload_data, indent=4).replace("\n", "\n    ")
        TEST_UPDATE_PAYLOAD_STR = json.dumps(update_payload_data, indent=4).replace("\n", "\n    ")
        
    except IndexError:
        print(colored("❌ ERROR: Not enough (at least 2) test cases available in testdata.json.", 'red'))
        sys.exit(1)


    # 4. Generate Pytest Code (Removed Docstrings)
    test_code = f"""
# test_mock_api.py
#
# THIS CODE WAS AUTOMATICALLY GENERATED BY generate_tests.py.
#
import requests
import pytest

# --- Configuration ---
BASE_URL = "{api_base}"
AUTH_HEADERS = {{"X-API-KEY": "MOCK_TOKEN_123"}}

# Test data from the generated 'testdata.json'
TEST_CREATE_PAYLOAD = {TEST_CREATE_PAYLOAD_STR}
TEST_UPDATE_PAYLOAD = {TEST_UPDATE_PAYLOAD_STR}


# Global variable to store the created ID for CRUD tests
global_id = None 

# --- Pytest Fixture (Setup) ---
@pytest.fixture(scope="module", autouse=True)
def setup_teardown():
    global global_id
    
    # 1. SETUP: Create an object for later testing
    print("\\n--- SETUP: Creating test object for CRUD tests ---")
    try:
        # POST request to create the resource
        response = requests.post(BASE_URL, headers=AUTH_HEADERS, json=TEST_CREATE_PAYLOAD, timeout=5)
        response.raise_for_status()
        global_id = response.json().get('id')
        assert global_id is not None
        print(f"    -> Object successfully created with ID: {{global_id}}")
    except Exception as e:
        print(f"    -> SETUP FAILED: {{e}}")
        pytest.fail(f"Setup object could not be created: {{e}}")
        
    yield 

    # 2. TEARDOWN: Clean up after tests 
    if global_id:
        print("\\n--- TEARDOWN: Deleting test object ---")
        try:
            # DELETE request for cleanup
            response = requests.delete(f"{{BASE_URL}}/{{global_id}}", headers=AUTH_HEADERS, timeout=5)
            # Accept 204 or 404
            if response.status_code not in [204, 404]:
                response.raise_for_status() 
            print("    -> Cleanup successful.")
        except Exception as e:
            print(f"    -> WARNING: Cleanup failed: {{e}}")
            global_id = None


# --- 1. Security/Auth Test ---
def test_post_creation_requires_auth():
    # Checks if POST requests without API key are rejected (401).
    response = requests.post(BASE_URL, json=TEST_CREATE_PAYLOAD, timeout=5)
    assert response.status_code == 401
    assert response.json().get("detail", "Detail field missing").startswith("Authorization required")

# --- 2. Read All Test ---
def test_get_all_success():
    # Checks if GET / is successful and returns a list.
    response = requests.get(BASE_URL, timeout=5)
    assert response.status_code == 200
    assert isinstance(response.json(), list)
    assert len(response.json()) > 0

# --- 3. Read One Test ---
def test_get_one_success():
    # Checks if GET /{{id}} returns the correct object.
    
    if global_id is None:
        pytest.skip("Setup failed: global_id not available.")

    response = requests.get(f"{{BASE_URL}}/{{global_id}}", timeout=5)
    assert response.status_code == 200
    assert response.json().get('id') == global_id

# --- 4. Update Test ---
def test_put_update_success():
    # Checks if PUT /{{id}} successfully updates the object.
    global global_id
    
    if global_id is None:
        pytest.skip("Setup failed: global_id not available.")
        
    update_data = TEST_UPDATE_PAYLOAD.copy() 
    update_data['id'] = global_id 
    
    # Send PUT request
    response = requests.put(f"{{BASE_URL}}/{{global_id}}", headers=AUTH_HEADERS, json=update_data, timeout=5)
    assert response.status_code == 200
    
    # Check if the response contains the updated object with the correct ID
    assert response.json().get('id') == global_id
    
    # Check updated value
    first_update_key = next(iter(TEST_UPDATE_PAYLOAD.keys()), None)
    if first_update_key:
        assert response.json().get(first_update_key) == TEST_UPDATE_PAYLOAD.get(first_update_key)


# --- 5. Delete Test ---
def test_delete_success():
    # Checks if DELETE /{{id}} is successful (204) and the object no longer exists afterwards (404).
    global global_id
    
    # 1. Temporarily create a new object
    try:
        response_post = requests.post(BASE_URL, headers=AUTH_HEADERS, json=TEST_CREATE_PAYLOAD, timeout=5)
        response_post.raise_for_status()
        temp_id = response_post.json().get('id')
        if temp_id is None:
             pytest.fail("Could not create a temporary object for the DELETE test.")
    except Exception as e:
        pytest.fail(f"Error creating temp object: {{e}}")


    # 2. Send DELETE request
    response_delete = requests.delete(f"{{BASE_URL}}/{{temp_id}}", headers=AUTH_HEADERS, timeout=5)
    assert response_delete.status_code == 204

    # 3. Check if the object is truly deleted
    response_check = requests.get(f"{{BASE_URL}}/{{temp_id}}", timeout=5)
    assert response_check.status_code == 404
    
    # The global ID for the fixture remains untouched.
"""

    # 5. Write file
    test_filename = "test_mock_api.py"
    # Write as 'ascii' to guarantee no Unicode characters sneak in
    with open(test_filename, 'w', encoding='ascii') as f:
        f.write(test_code)
        
    print(colored(f"✅ Pytest file successfully generated in '{test_filename}'.", 'green'))
    print(colored("\nTo run the tests, start: 'python mock_server.py' (in Tab 1) and then 'pytest' (in Tab 2).", 'cyan'))


if __name__ == "__main__":
    create_api_tests()